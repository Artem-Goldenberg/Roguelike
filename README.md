# Roguelike
Игра с продуманной архитектурой? (:3)
## Зависимости
Чтобы установить необходимые зависимости необходимо установить библиотеку `pygame`:
```
pip install pygame
```

## Запуск
Скопируйте проект на свой компьютер, откройте консоль и зайдите в корень скачанного проекта. После этого запустить проект можно с помощью команды
```
python main.py
```

# Архитектурные решения и их причины

## 1. Чанки

Прорисовывать каждый фрейм всю карту, которая может быть довольно большая -- очень дорогая операция. Чтобы этого избежать мы использовали стандартное решение: разбить карту на "чанки", то есть блоки. В каждый момент прорисовываются только 9 чанков, а именно тот, в котором находится игрок и 8 соседних, чтобы карта казалось непрерывной и игрок не шагал "в пустоту" при переходе из одного блока в другой.

Данное решение налагает определенные обязательства на разработчика: каждый объект должен быть привязан к конкретному чанку и если он, вдруг, переходит из одного чанка в другой, то нужно переносить его в другой чанк. Кроме того нужно вовремя подгружать и выгружать чанки из пула отрисовываемых.

## 2. Логика и графика

У каждого объекта на карте есть несколько логических аспектов, которые нужно реализовать: логика поведения и графическое отображение этого самого поведения. Графика, несомненно, зависит от логики, однако логика о графике знать не должна, так как это добавляет одному модулю сразу две ответственности и существенно усложняет разрабтку: нужно помнить не только о том что делает персонаж, но и следить за его отрисовкой. 

Мы разнесли графику и логику в отдельные классы: EntityLogic и EntityGraphics. Однако наследовать одно от другого означает серьезные проблемы с тестируемостью, более того возникает проблема подстановки одного класса вместо другого. Хранить ссылку на логику в графике так же не правильно, так как графике не нужен весь класс логики, а только какие то параметры текущего состояния. Решением данного конфликта выступает класс EntityData, доступ к которому имеет как графика, так и логика. В этом классе хранятся только параметры сущности, читая которые графика может корректно отрисовываться. Логика же может изменять эти параметры, тем самым влияя на отрисовку.

У данного решения есть один неоспоримый плюс: логика и графика работают независимо и с легкостью могут быть заменены аналогами:
* Поменяв графику мы можем не повредив ничего заменить модель персонажа, более того, в графике, в теории, возможно реализовать более сложные сценарии отображения такие как раны на модельке при низком уровне здоровья или отображение модельки лука на герое, если у него действительно есть лук в инвентаре
* Поменяв логику мы можем создать нового героя без необходимости переделывать его графическую составляющую

## 3. Стейты 

Говоря о минусах такого разделения можно выделить необходимость унифицировать данные сущности, чтобы логика и графика друг друга понимали. Наиболее эффективным решением мы посчитали введение "стейта" или состояния персонажа, а так же этап данного состояния. 

В качестве примера можно разобрать передвижение. Состояние ходьбы влево описывается лишь начальным положением и тем сколько времени прошло с начала движения. Этого достаточно для отрисовки, а так же достаточно для того, чтобы решить получать ли урон, который прилетел в клетку, в которой герой стоял. Если мы только начали движение, то, конечно, получать. Иначе можно считать, что мы уже ушли из клетки и удар "промазал".

## 4. Единый контейнер 

Чтобы унифицировать общение с сущностью мы создали класс Entity, который агрегирует в себе EntityLogic, EntityGraphics и EntityData. Это позволило хранить в чанке список сущностей и давать некоторую гарантию, что все модули не перепутаются и никакие две EntityGraphics не будут пытаться отрисовывать одни и те же данные.

## 5. Мета-логика 

Как оказалось на практике, нам не достаточно одной лишь простой логики. Мобы должны не просто ходить, получать урон и бить окружающее пространство, они должны реагировать на игрока, бежать к нему на встречу, от него, обходить сзади. Эти стратегии на деле никак не связаны с тем КАК именно ходят персонажи или КАК они получают урон, они "мыслят" глобальнее. Совмещать такое поведение с уже имеющейся логикой состояяний было бы чрезвычайно сложно, так как число состояний и переходов между ними увеличилось бы в разы и такое невозможно было бы адекватно поддерживать, по этому мы завели новый класс EntityMetaLogic.

Этот класс так же завсит только от EntityData, однако отвечает он за глобальное поведение. Реализовано это через дополнительное поле в классе EntityData, которое содержит список интрукций для сущности. Идейно это как сигналы, поступающие от мозга к телу. Мета-логика видит и реагирует на окружающий мир не думая о том, как конкретно ходит персонаж и должен ли он сейчас получать урон или бить. Она говорит "сейчас нужно бить" и персонаж бьет, если он в состоянии, в котором может бить. Если он в этот момент идет, то он не ударит, так как это зашито в его логику и об этом не нужно беспокоиться разработчику. Однако мета-логика нужна не всем объектам на карте, а только активным и она напрямую расширяет обычный Entity. По этому через наследвание данный функционал  поддерживается в классе ActiveEntity: Entity, в котором есть новые поля ActiveEntityData (вместо обычной EntityData) и EntityMetaLogic.

## 6. Event System 

Чтобы обеспечивать корректную работу одной сущности, нам нужно обеспечить ее взаимодействие с другими сущностями в мире. Для примера рассмотрим получение и нанесение урона. Каждая сущность должна сама отрисовывать удар и решать когда нужно его нанести. Если эта же сущность будет решать кому она наносит урон, то возникнет слишком много проблем: сущность должна знать о всех других и, более того, иметь доступ на изменение состояний других сущностей, что влечет знание о всех состояниях других сущностей. Так, конечно, делать нельзя.

Решением поступило введение глобальной системы событий (EventSystem), доступ к которой есть у всех сущностей. Если сущность хочет нанести урон, то она просто посылает сигнал: "урон по клетке Х". Все остальные же сущности подписываются на получение таких событий и если в их клетку прилетает урон, то они сами уменьшают свое здоровье, меняют состояние и так далее.

Данное решение, конечно, разрешает сущностям, например, игнорировать урон, что выглядит не естественно, однако данная проблема легко выявляется и легко исправляется, так как затрагивает только одну конкретную сущность.

## 7. Фабрики

Как и в любой игре нам нужно создавать много объектов, которые обладают каждый своей графикой, логикой, мета-логикой и прочими параметрами. Делать это вручную, конечно, можно, но это сильно увеличивает трудозатраты на добавление одного персонажа и значительно затрудняет изменение его параметров. Чтобы унифицировать создание сущностей мы используем две фабрики. Одна создает персонажа по заданному названию его логики, мета-логики (если имеется), графики и списку вещей в инвентаре. Вторая создает объекты инвентаря по названию. Это позволяет, например, изменив одну строчку полностью заменить главного героя на скелета, а так же помогает упроститить создание готовых карт для игры. Так для создания нового персонажа на сцене достаточно указать в конфигурационном файле название заранее написанной логики, мета-логики, графики и позицию и при запуске игры заданный персонаж появится.

## 8. Генерация карты

Прежде всего есть стандартная рандомная генерация чанков. Она применяется, если чанк не задан никаким другим способом. Кроме того есть специальный конфигурационный файл map.cfg в котором можно задать все необходимые Вам объекты по координатам. Эти объекты автоматически добавятся в соответствующие чанки, случайная генерация к таким чанкам применена не будет.

## 9. Логгирование

Для простоты отладки есть два уровня логирования. Первый выводится в консоль и позволяет отслеживать происходящие события в режиме реального времени. Данный лог, к сложалению, пропадет после закрытия консоли, более того, если выводить туда слишком много информации, то это будет сложно воспринимать. Для подробного лога есть второй уровень логирования -- в файл. При запуске игры создается файл rogue_like.log в корневой директории проекта. В него дописываются все логи и перманентно сохраняются даже если игра или консоль по какой то причине перестают работать.   
